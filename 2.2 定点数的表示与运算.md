2.2 定点数的表示与运算

|惜取少年时 2020-09-15 07:57:25  435  收藏 2
分类专栏： 计算机组成原理
版权

计算机组成原理
专栏收录该内容
36 篇文章4 订阅
订阅专栏
返回目录《计算机组成原理笔记目录（2019 王道考研）》

2.2 定点数的表示与运算
本节内容
    1.定点数的表示
        无符号数
        有符号数：原码、补码、反码、移码
    2.定点数的运算
        移位、加减、溢出判断、乘除、强制类型转换
    
1.无符号数与原码
    1.无符号数：整个机器字长的全部二进制位均为数值位，没有符号位，相当于数的绝对值
        取值范围：0~2^无符号位数-1
        **有符号数与小数怎么表示？
            符号位，定点数
    2.纯小数原码
        原码=符号位+真值
        符号位：0表示正号，1表示负数
        [x]原=x    0<=x<1
            =1-x  -1<x<=0（即：在x绝对值的前面拼接1）
        若字长为n，则原码小数的表示范围为-(1-2^(n-1))<=x<=1-2^(n-1)（关于原点对称）
    3.纯整数原码
        [x]原=x    0<=x<2^n
            =2^n-x -2^n<x<=0（即：在x绝对值前面拼接1）
        若字长为n，原码整数的表示范围为：-(2^(n-1)-1)<=x<=2^(n-1)-1（关于原点对称）
    4.原码的问题，计算时需要判断符号位，然后分类讨论
        解决办法：使用补码，用加法代替加法和减法
2.补码反码移码
    1.补码
        一个数的补码：
            正数不变，负数符号位不变，数值位取反加1
        已知一个数的补码，求该数的相反数的补码：（怎么证明？）
            连同符号位一起取反加1
        1.纯整数补码
            [x]补=0，x        2^n>x>=0
                =2^(n+1)+x    0>=x>=-2^n
            取值范围
                若字长为n+1，则补码的表示范围为-2^n<=x<=2^n-1
                补码比原码多了一个数
        2.纯小数的补码
            [x]补=x   1>x>=0
                =2+x  0>x>=-1
            取值范围
                若字长为n+1，则补码的表示范围为-1<=x<=1-2^(-n)
    2.反码
        正数：反码与原码相同
        负数：原码符号位不变，树枝部分按位取反（此规则同样适用于由反码转化为原码）
        表示范围与原码一样
        1.纯整数反码
            [x]补=0，x          2^n>x>=0
                =2^(n+1)-1+x    0>=x>-2^n
            取值范围与原码相同（关于原点对称）
        2.纯小数反码
            [x]补=x   1>x>=0
                =2+x  0>x>-1
            取值范围与原码相同（关于原点对称）
        3.原补反相互转换
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54


    3.移码
        方便判断两值的大小
        移码就是在真值x上减去一个常数（偏置值），通常这个常数取2^n,
            n是真值x的位数，不是移码的位数，是不加符号位的位数
        移码与补码的取值范围相同
        移码与补码可以相互转换，
            当移码的符号位是0时，补码的符号位是1
            当移码的符号位是1时，补码的符号位是0
3.移位运算
    r表示基数
    右移n位：除以r^n；左移n位：乘以r^n
    1.机器数采用无符号数：逻辑移位
        逻辑左移，高位丢失，低位填0
        逻辑右移，低位丢失，高位填0
    2.机器数采用有符号数：算数移位
        **符号位不参与移位
        1.原码算数移位
            左移、右移都补0
            左移丢1：出错；右移丢1，影响精度
        2.补码算数移位
            正数：左移右移都补0
            负数：左移补0，右移补1
        3.反码算数移位
            正数：左移右移都补0
            负数：左移右移都补1
        4.循环移位示意图（了解）
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26


4.加减运算、符号扩展、溢出判断
    1.加减运算的3个操作
        1.[A+B]补=[A]补+[B]补
        2.[A-B]补=[A]补+[-B]补
        3.[-B]补与[B]补的关系，连同符号位按位取反后加一
    2.溢出判断
        1.正溢出（上溢出）和负溢出（下溢出）
            正溢出：两个正数相加变成了负数
            负溢出：两个负数相加变成了正数
        2.判断方法1：采用一位符号位
            设A的符号位为As，B的符号位为Bs，运算结果为Ss，则溢出逻辑表达式为
            使用真值表，写出最小项得：
                V=As·Bs·~Ss+~As·~Bs·Ss
            若V=0，则表示无溢出
            若V=1，则表示有溢出
        3.判断方法2：采用一位符号位，根据数据位进位情况判断溢出
            设符号位的进位为Cs，最高数位的进位C1
            正溢出时，Cs=0，C1=1
            负溢出时，Cs=1，C1=0
            即Cs和C1不同时，则有溢出
                即：V=Cs⊕C1
            若V=0，则表示无溢出
            若V=1，则表示有溢出
        4.判断方法3：采用双符号位（在计算机的设计中常使用）
            正数符号位为00，负数符号位为11
            记两个符号位为S1S2
                则：V=S1⊕S2
            若V=0，则表示无溢出
            若V=1，则表示有溢出
        5.双符号位
            1.采用双符号位的移位运算：
                低位符号位参与移位，高位符号位代表真正的符号
            2.双符号位实际存储时，只存储一个符号位，这是因为存在存储器中的数字，
                先保证了它是一个正常的数字，不是溢出的情况  
            3.在需要运算的时候，是会把符号位并行地送到用于存储符号位的两个存储单元中
            补充：双符号位的移位操作举例：
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36


5.定点数的乘法运算（使用移位和加法来代替乘法）
    2.原码一位乘法（使用双符号位，方便处理溢出的问题）
        符号位与数值位分开处理，符号位通过异或运算获得结果
        ACC：存放乘积高位
        MQ：存放乘数、乘积低位
        X：存放被乘数  
        原码一位乘法示例（以纯小数为例）
1
2
3
4
5
6
7


    3.补码Booth乘法（使用双符号位）
        采用Booth算法
        补码一位乘法示例（以纯小数为例）
1
2
3


    4.定点数乘法总结
1


6.C语言强制类型转换        
    1.无符号数与有符号数转换：
        不改变数据内容，只改变解释方式
        比如有符号数，1110 1111 0001 1111是[-4321]补
        short x=-4321;  
        //在计算机中存储的二进制为1110 1111 0001 1111
        unsigned short y=(unsigned short)x;  
        //在计算机中的存储内容不变还是1110 1111 0001 1111，但是解释方式发生改变解释为无符号数61215
    2.长数据类型转化为短数据类型
        高位截断，保留低位
        感兴趣的话，可以自己编写C程序验证
    3.短数据类型转化为长数据类型
        填充高位
        不会影响真值
    写程序的时候，要避免前两种数据转换
7.定点数的除法运算（使用移位和减法代替除法）（没弄懂，以后要结合题目具体分析）
    1.原码恢复余数法
        计算机进行控制的时候，使用一个计数器记录左移和上商的次数
        左移和上商的次数是固定的，中间需要恢复的次数是没有办法预计的
        这样的话使用计数器来控制，会产生麻烦
        ACC：被除数，余数
        MQ：商
        X：余数
        n是数值的位数
        原码恢复余数法示例
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25


        不恢复余数法
            把恢复过程穿插到上商过程中
            使用左移+b，完成恢复和减去的操作
1
2
3



    2.原码加减交替法（即：原码不恢复余数法）  
    3.补码加减交替法
1
2


    4.除法运算总结回顾
1

————————————————
版权声明：本文为CSDN博主「|惜取少年时」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/inv1796915552/article/details/108592055